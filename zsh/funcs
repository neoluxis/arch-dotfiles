# 配置命令免密
nopass() {
    local sudoer_dir="/etc/sudoers.d"

    if [ -z "$1" ]; then
        # 所有命令免密
        local sudoer_file="$sudoer_dir/nopass-all"
        echo "$USER ALL=(ALL) NOPASSWD: ALL" | sudo tee "$sudoer_file" >/dev/null \
            && echo "已为 $USER 设置所有命令免密 sudo"
        return 0
    fi

    local cmd_path
    cmd_path=$(command -v "$1" 2>/dev/null)

    if [ -z "$cmd_path" ]; then
        echo "错误: 找不到命令 $1"
        return 1
    fi

    local sudoer_file="$sudoer_dir/nopass-$1"

    echo "$USER ALL=(ALL) NOPASSWD: $cmd_path" | sudo tee "$sudoer_file" >/dev/null \
        && echo "已为 $1 ($cmd_path) 设置免密 sudo"
}

# 取消命令免密
setpass() {
    local sudoer_dir="/etc/sudoers.d"

    if [ -z "$1" ]; then
        # 取消所有免密
        sudo find "$sudoer_dir" -maxdepth 1 -type f -name 'nopass-*' -delete
        sudo rm -f "$sudoer_dir/nopass-all"

        if [ -n "$(sudo ls "$sudoer_dir" | grep '^nopass-')" ] || sudo test -f "$sudoer_dir/nopass-all"; then
            echo "错误: 部分免密未能删除"
        else
            echo "已取消所有免密 sudo"
        fi
        return 0
    fi

    local sudoer_file="$sudoer_dir/nopass-$1"

    if sudo test -f "$sudoer_file"; then
        sudo rm -f "$sudoer_file" \
            && echo "已取消 $1 的免密 sudo"
    else
        echo "错误: 没有为 $1 设置免密"
        return 1
    fi
}

# 查看免密的命令
listpass() {
    local sudoer_dir="/etc/sudoers.d"
    local files
    files=$(sudo ls "$sudoer_dir" 2>/dev/null | grep '^nopass-' || true)

    if [ -z "$files" ]; then
        echo "当前没有配置免密命令"
        return 0
    fi

    echo "当前免密配置："
    for f in $files; do
        if [ "$f" = "nopass-all" ]; then
            echo "  [ALL] 所有命令免密"
        else
            echo "  ${f#nopass-}"
        fi
    done
}


# 环境初始化工具
nlx_init_ros2() {
    # ROS2 环境初始化，Humble支援
    if [ -f /opt/ros/humble/setup.zsh ]; then
        export ROS_DOMAIN_ID=42
        source /opt/ros/humble/setup.zsh
    else
        echo "No ROS Humble Installation Found!! "
        return 1
    fi
}
nlx_init_conda() {
    # Conda 环境初始化，Anaconda与Miniconda支援
    if [ -f /opt/anaconda/bin/conda ]; then
        export CONDA=anaconda
        export CONDA_PREFIX=/opt/anaconda
    elif [ -f /opt/miniconda3/bin/conda ]; then
        export CONDA=miniconda
        export CONDA_PREFIX=/opt/miniconda3
    else
        echo "No Conda Installation Found! "
        return 1
    fi

    __conda_setup="$(\"${CONDA_PREFIX}/bin/conda\" 'shell.zsh' 'hook' 2> /dev/null)"
    if [ $? -eq 0 ]; then
        eval "$__conda_setup"
    else
        if [ -f "${CONDA_PREFIX}/etc/profile.d/conda.sh" ]; then
            . "${CONDA_PREFIX}/etc/profile.d/conda.sh"
        else
            export PATH="${CONDA_PREFIX}/bin:$PATH"
        fi
    fi
    unset __conda_setup

    # 用于防止 SSL 报错，或者可以通过root后更新conda base环境解决
    export CRYPTOGRAPHY_OPENSSL_NO_LEGACY=1
}
nlx_init_oneapi() {
    # Intel Oneapi 环境初始化
    if [ -f /opt/intel/oneapi/setvars.sh ]; then
        LOGFILE="/tmp/intel-oneapi-init-$(whoami)-$(date '+%Y-%m-%d_%H-%M-%S').log"
        source /opt/intel/oneapi/setvars.sh > "$LOGFILE" 2>&1
    fi
}
nlx_init_pyenv() {
    export PYENV_ROOT="$HOME/.pyenv"
    [[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
    eval "$(pyenv init - zsh)"
}

# 环境初始化
initer() {
	if [ "$1" = "ros2" ]; then
		nlx_init_ros2
	elif [ "$1" = "conda" ]; then
        nlx_init_conda
	elif [ "$1" = "pyenv" ]; then
        nlx_init_pyenv
	elif [ "$1" = "oneapi" ]; then
        nlx_init_oneapi
	else
		echo "Usage: initer <ros2|conda|oneapi> [-h]"
	fi
}

# 任务管理，完成任务后邮件通知
tasker() {
    local cmd=""
    local script=""
    local to=""
    local screen_mode=0

    # 解析参数
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c) cmd="$2"; shift 2;;
            -t) to="$2"; shift 2;;
            --screen) screen_mode=1; shift;;
            -h)
                echo "Usage:"
                echo "  tasker [script_path] [-c \"command\"] [-t \"recipient\"] [--screen] [-h]"
                echo "  script_path   Path to script to execute (optional if -c is used)"
                echo "  -c            Command to execute"
                echo "  -t            Email address to send report to (overrides config)"
                echo "  --screen      Show output in terminal while executing"
                echo "  -h            Show this help message"
                return 0
                ;;
            --) shift; break;;
            -*) echo "Unknown option: $1"; echo "Use -h for help"; return 1;;
            *)  # 第一个非选项参数当作脚本路径
                if [[ -z "$script" ]]; then
                    script="$1"
                else
                    echo "Unknown argument: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done

    # 必须提供命令或脚本
    if [[ -z "$cmd" && -z "$script" ]]; then
        echo "Error: no command or script specified. Use -c or provide a script path"
        return 1
    fi

    # 检查脚本是否存在
    if [[ -n "$script" && ! -f "$script" ]]; then
        echo "Error: script '$script' does not exist."
        return 1
    fi

    # 收件人
    if [[ -z "$to" ]]; then
        if [[ -f "$HOME/.config/tasker/config.yaml" ]]; then
            to=$(grep -E '^target_addr:' "$HOME/.config/tasker/config.yaml" | awk '{print $2}')
        fi
        if [[ -z "$to" ]]; then
            echo "Error: No target email specified and failed to read from config."
            echo "Please provide -t or set target_addr in ~/.config/tasker/config.yaml"
            return 1
        fi
    fi

    # 创建异步脚本
    local async_script
    async_script=$(mktemp)
    cat > "$async_script" <<'EOF'
#!/usr/bin/env bash
cmd="$CMD"
script="$SCRIPT"
to="$TO"
screen_mode="$SCREEN_MODE"

status=0
output_file=$(mktemp)

# 构建任务描述
if [[ -n "$cmd" ]]; then
    exec_desc="Command: $cmd"
    if [[ "$screen_mode" -eq 1 ]]; then
        bash -c "$cmd" | tee "$output_file"
        status=${PIPESTATUS[0]}
    else
        bash -c "$cmd" > "$output_file" 2>&1
        status=$?
    fi
elif [[ -n "$script" ]]; then
    fullpath=$(realpath "$script" 2>/dev/null || echo "$script")
    exec_desc="Script: $fullpath"
    if [[ "$screen_mode" -eq 1 ]]; then
        bash "$script" | tee "$output_file"
        status=${PIPESTATUS[0]}
    else
        bash "$script" > "$output_file" 2>&1
        status=$?
    fi
fi

output_preview=$(tail -n 30 "$output_file")

if [[ $status -eq 0 ]]; then
    subject="任务完成（成功）"
else
    subject="任务完成（失败）"
fi

{
    echo "Subject: $subject"
    echo "To: $to"
    echo
    echo "Task Description:"
    echo "$exec_desc"
    echo
    echo "Exit Status: $status"
    echo
    echo "Output Preview (last 30 lines):"
    echo "$output_preview"
    echo
    echo "Full output saved at: $output_file"
} | msmtp -t "$to"

rm -f "$async_script"
EOF

    chmod +x "$async_script"

    CMD="$cmd"
    SCRIPT="$script"
    TO="$to"
    SCREEN_MODE="$screen_mode"

    if [[ "$screen_mode" -eq 1 ]]; then
        # 前景执行
        env CMD="$CMD" SCRIPT="$SCRIPT" TO="$TO" SCREEN_MODE="$SCREEN_MODE" bash "$async_script"
    else
        # 异步后台执行，不阻塞终端，不输出无用信息
        nohup env CMD="$CMD" SCRIPT="$SCRIPT" TO="$TO" SCREEN_MODE="$SCREEN_MODE" bash "$async_script" >/dev/null 2>&1 </dev/null &
        disown
        echo "Task started in background, email will be sent to $to"
    fi
}

